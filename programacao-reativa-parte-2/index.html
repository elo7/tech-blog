<!DOCTYPE html>
<html>
    <head>
	<meta charset='UTF-8'>
	<meta name='viewport' content='width=device-width, initial-scale=1'>
	<meta name='description' content='Blog de tecnologia do Elo7, mantido pelo nosso time de Engenharia, compartilhando conhecimento e mostrando como é o dia a dia de um colaborador fora de série.'>
	<meta name='google-site-verification' content='NqCILBTY8B8P-r_KF8BSZKH9kUQgQOEbXJvEMaB33vw'>
	<meta name='google-site-verification' content='cKh-stJM3_ENNfMjaBIIyYiDgMXZFpRkoH8eQTcPwhM' />
	<meta name="google-site-verification" content="6Er6NBhORIKrEwdS46h772O_7LTE9vWgZjwtzuZ5gpQ" />
	<meta name='theme-color' content='#FDC24F'>
	<meta name='keywords' content='Elo7,tecnologia,post,desenvolvimento,blog,java,programacao-reativa,'>
	<meta name='language' content='pt-br'>
	<meta name='title' content='Elo7 Tech - Programação Reativa - Parte 2: RxJava'>
	<meta name='apple-mobile-web-app-title' content='Elo7 Tech - Programação Reativa - Parte 2: RxJava'>
	<meta name='mobile-web-app-capable' content='yes'>

	<meta property='fb:app_id' content='644444999041914'>
	<meta property='fb:admins' content='100003324447975'>

	<meta property='og:site_name' content='Elo7 Tech'>
	<meta property='og:image' content='https://blog.elo7.dev/images/cover/programacao-reativa-parte-2.png'>
	<meta property='og:type' content='website'>
	<meta property='og:title' content='Elo7 Tech - Programação Reativa - Parte 2: RxJava'>
	<meta property='og:url' content='https://blog.elo7.dev/programacao-reativa-parte-2/'>
	<meta property='og:description' content='Blog de tecnologia do Elo7, mantido pelo nosso time de Engenharia, compartilhando conhecimento e mostrando como é o dia a dia de um colaborador fora de série.'>

	<meta name='twitter:widgets:csp' content='on'>
	<meta name='twitter:card' content='summary_large_image'>

	<meta property='twitter:title' content='Elo7 Tech - Programação Reativa - Parte 2: RxJava'>
	<meta property='twitter:domain' content='https://blog.elo7.dev/'>
	<meta property='twitter:url' content='https://blog.elo7.dev/programacao-reativa-parte-2/'>
	<meta property='twitter:description' content='Blog de tecnologia do Elo7, mantido pelo nosso time de Engenharia, compartilhando conhecimento e mostrando como é o dia a dia de um colaborador fora de série.'>
	<meta property='twitter:image' content='https://blog.elo7.dev/images/cover/programacao-reativa-parte-2.png'>

	<link rel='canonical' href='https://blog.elo7.dev/programacao-reativa-parte-2/'>
	<title>Elo7 Tech - Programação Reativa - Parte 2: RxJava</title>
	<link rel='stylesheet' href='https://blog.elo7.dev/css/reset.css'>
	<link rel='stylesheet' href='https://blog.elo7.dev/css/vendor/highlight.css' >
	<link rel='stylesheet' href='https://blog.elo7.dev/css/main.css' >
	<link rel='stylesheet' href='https://blog.elo7.dev/css/posts.css' >
	<link rel='stylesheet' href='https://blog.elo7.dev/css/post.css' >
	<link rel='stylesheet' href='https://blog.elo7.dev/css/publisher.css' >
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-16.png' sizes='16x16'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-32.png' sizes='32x32'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-48.png' sizes='48x48'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-64.png' sizes='64x64'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-96.png' sizes='96x96'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-128.png' sizes='128x128'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-160.png' sizes='160x160'>
	<link rel='icon' href='https://blog.elo7.dev/images/favicon/favicon-192.png' sizes='192x192'>
	<link rel='apple-touch-icon-precomposed' sizes='180x180' href='https://blog.elo7.dev/images/favicon/favicon-180.png'>
	<link rel='apple-touch-icon-precomposed' sizes='152x152' href='https://blog.elo7.dev/images/favicon/favicon-152.png'>
	<link rel='apple-touch-icon-precomposed' sizes='144x144' href='https://blog.elo7.dev/images/favicon/favicon-144.png'>
	<link rel='apple-touch-icon-precomposed' sizes='120x120' href='https://blog.elo7.dev/images/favicon/favicon-120.png'>
	<link rel='apple-touch-icon-precomposed' sizes='114x114' href='https://blog.elo7.dev/images/favicon/favicon-114.png'>
	<link rel='apple-touch-icon-precomposed' sizes='76x76' href='https://blog.elo7.dev/images/favicon/favicon-76.png'>
	<link rel='apple-touch-icon-precomposed' sizes='72x72' href='https://blog.elo7.dev/images/favicon/favicon-72.png'>
	<link rel='apple-touch-icon-precomposed' sizes='60x60' href='https://blog.elo7.dev/images/favicon/favicon-60.png'>
	<link rel='apple-touch-icon-precomposed' sizes='57x57' href='https://blog.elo7.dev/images/favicon/favicon-57.png'>
	<link rel='apple-touch-icon-precomposed' href='https://blog.elo7.dev/images/favicon/favicon-precomposed.png'>
	<script>window.addEventListener('error', window.__e=function f(e){f.q=f.q||[];f.q.push(e)});</script>
	<script src='/js/vendor/async-define.js'></script>
</head>

    <body data-env='production' data-ga-code='UA-3692628-29'>
        <meta name='page_type' content='post'>
        <meta name='category' content='back-end'>
        <header class='left-pane'>
    <div class='logo-container'>
        <a rel='home' itemprop='url' href='https://blog.elo7.dev/' class='logo'>Tech Blog Elo7</a>
    </div>
    <div class='navigation'>
        <input id='categories-switch' type='checkbox' class='categories-switch'>
        <label for='categories-switch' class='selectable'>
            <h2 class='nav-title'>Categorias</h2>
        </label>
        <nav aria-label='Navegue pelas categorias do nosso blog' class='nav-list nav-category'>
            
                <a href='/categoria/back-end' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Back End</a></span>
                </a>
            
                <a href='/categoria/big-data' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Big Data</a></span>
                </a>
            
                <a href='/categoria/cultura' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Cultura</a></span>
                </a>
            
                <a href='/categoria/design' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Design</a></span>
                </a>
            
                <a href='/categoria/devops' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Devops</a></span>
                </a>
            
                <a href='/categoria/eventos' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Eventos</a></span>
                </a>
            
                <a href='/categoria/front-end' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Front End</a></span>
                </a>
            
                <a href='/categoria/machine-learning' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Machine Learning</a></span>
                </a>
            
                <a href='/categoria/mobile' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Mobile</a></span>
                </a>
            
                <a href='/categoria/vagas' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                    <span itemprop='name'>Vagas</a></span>
                </a>
            
            <a href='/talks' itemscope itemtype='http://schema.org/SiteNavigationElement'>
                <span itemprop='name'>Palestras</span>
            </a>
        </nav>
    </div>
    <div class='navigation'>
        <input id='more-switch' type='checkbox' class='more-switch'>
        <label for='more-switch' class='selectable'>
            <h2 class='nav-title'>Veja também</h2>
        </label>
        <nav class='nav-list nav-more' aria-label='Navegue pelos links relacionados ao Elo7'>
            <a itemprop='relatedLink' href='/meetups'>
                <span itemprop='name'>Meetups no Elo7</span>
            </a>
            <a itemprop='relatedLink' href='http://carreira.elo7.com.br/engenharia/' target='_blank'>
                <span itemprop='name'>A engenharia</span>
            </a>
            <a itemprop='relatedLink' href='http://carreira.elo7.com.br/' target='_blank'>
                <span itemprop='name'>Carreiras</span>
            </a>
            <a itemprop='relatedLink' href='http://elo7.com.br/' target='_blank'>
                <span itemprop='name'>Elo7</span>
            </a>
        </nav>
    </div>
    <div class='social'>
        <a title='Github do Elo7' rel='external' itemprop='relatedLink' href='https://github.com/elo7' target='_blank' class='github'>Github do Elo7</a>
        <a title='Twitter do Elo7' rel='external' itemprop='relatedLink' href='https://twitter.com/elo7tech' target='_blank' class='twitter'>Twitter do Elo7</a>
        <a title='RSS do Elo7' rel='external' itemprop='relatedLink' href='https://blog.elo7.dev/index.xml' target='_blank' class='rss'>RSS do Elo7</a>
        <a title='Newsletter do Elo7' rel='external' itemprop='relatedLink' href='http://eepurl.com/cVUwvH' target='_blank' class='email'>Newsletter do Elo7</a>
    </div>
</header>

        <main aria-label='Conteúdo principal' itemscope itemtype='http://schema.org/Blog'>
            <article itemprop='blogPost' itemscope itemtype='http://schema.org/BlogPosting' class='post-main'>
                <figure class='cover-image' itemprop="image" itemscope itemtype="http://schema.org/ImageObject">
                    <img src='/images/cover/programacao-reativa-parte-2.png' alt='Programação Reativa - Parte 2: RxJava' itemprop="url">
                </figure>
                <div class='post-content'>
                    <h1 itemprop='name' class='title'>Programação Reativa - Parte 2: RxJava</h1>
                    <div class='post-meta'>
                        <p class='date'>
                            Publicado em:
                            <time class='date'
    datetime='2018-05-21 00:00:00 &#43;0000 UTC'
    aria-label='21 de maio de 2018'>
    21/05/2018
    <meta itemprop='datePublished' content='Mon May 21 2018 00:00:00 GMT&#43;0000 (UTC)'/>
    <meta itemprop='dateModified' content='Mon May 21 2018 00:00:00 GMT&#43;0000 (UTC)'>
    <meta name='date' content='2018-05-21'>
</time>

                        </p>

                        <article>
                            
                                <a data-author='ljtfreitas' itemprop='author' itemscope itemtype='http://schema.org/Person' rel='author' href='/autor/ljtfreitas/' class='author'>
                                    <meta name='author' itemprop='url' content='/autor/ljtfreitas'>
                                    <img class='hide avatar' width='50px' height='50px' itemprop='image'>
                                    <p itemprop='name' class='publisher' data-author='ljtfreitas'>@ljtfreitas</p>
                                </a>
                            

                            <meta itemprop='worksFor' content='Elo7 Serviços de Informática SA'>
                        </article>
                    </div>
                    <div itemprop='articleBody'>
                        

<p>No <a href="/programacao-reativa">post anterior</a>, vimos os fundamentos da programação reativa, incluindo o funcionamento básico sobre os quais os frameworks da família <a href="http://reactivex.io/">ReactiveX</a> são implementados. Nessa segunda fase da nossa &ldquo;jornada reativa&rdquo;, começaremos a estudar os principais recursos e funcionalidades do <a href="https://github.com/ReactiveX/RxJava">RxJava</a>, e então estaremos mais preparados para aplicar esses conceitos - não apenas em &ldquo;programas&rdquo; mas em &ldquo;sistemas&rdquo;, os chamados <strong>sistemas reativos</strong>.</p>

<p>Os exemplos deste post estão implementados com o RxJava (a versão 2, compatível com o <a href="http://www.reactive-streams.org/">Reactive Streams</a>, que tem <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">algumas diferenças</a> para a versão anterior). Porém, os mesmos fundamentos são aplicáveis em qualquer outro framework da família Rx, ou mesmo outros frameworks reativos como o <a href="https://projectreactor.io/">Reactor</a>.</p>

<blockquote>
<p><em>“É fazendo que se aprende o que se deve aprender a fazer. (Aristóteles)”</em></p>
</blockquote>

<h2 id="observables">Observables</h2>

<p>Conforme dito (superficialmente) no <a href="/programacao-reativa">post anterior</a>, a principal classe do RxJava é o <a href="http://reactivex.io/documentation/observable.html">Observable</a>, que representa um fluxo de dados (contínuos ou discretos, finitos ou infinitos). Essa classe contêm todos os operadores reativos disponíveis no RxJava. Para nossos propósitos, podemos criar uma instância a partir de uma lista de valores fixos, e nos <em>subscrevermos</em> ao <code>Observable</code> criado:</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable.subscribe(System.out::println);

/*
output:

one
two
three
*/
</code></pre>

<p>Nesse código, nós estamos executando uma ação no evento <em>onNext</em>. Recapitulação rápida: <em>onNext</em> é o evento que representa a emissão de um valor pelo Observable. Os outros dois eventos possíveis em um fluxo reativo são o <em>onError</em> e o <em>onCompleted</em>. Se quiséssemos executar algum código quando esses dois eventos ocorressem, poderíamos usar as sobrecargas do método <em>subscribe</em>:</p>

<pre><code class="language-java">//onError

Observable&lt;String&gt; observable = Observable.error(new RuntimeException(&quot;ooops...&quot;)); // esse Observable irá emitir apenas um erro

observable.subscribe(System.out::println, Throwable::printStackTrace); //o segundo parâmetro é a ação que deverá ser realizada em caso de erro (um Consumer que recebe um Throwable)

/*
output:

java.lang.RuntimeException: ooops...
*/
</code></pre>

<pre><code class="language-java">//onCompleted

Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;Completed...&quot;)); //o terceiro parâmetro é a ação que deverá ser realizada quando o Observable for completado (um objeto do tipo Action que não recebe parâmetros)

/*
output:

one
two
three
Completed...
*/
</code></pre>

<pre><code class="language-java">//outra maneira é se subscrever usando um objeto do tipo Observer; desse modo você pode implementar as acões de cada evento em um único objeto

Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable.subscribe(new Observer&lt;String&gt;() {

	@Override
	public void onSubscribe(Disposable d) {
		System.out.println(&quot;Alguém se subscreveu...&quot;);
	}

	@Override
	public void onNext(String t) {
		System.out.println(t);
	}

	@Override
	public void onError(Throwable e) {
		e.printStackTrace();
	}

	@Override
	public void onComplete() {
		System.out.println(&quot;Completed...&quot;);
	}
});

/*
output:

Alguém se subscreveu...
one
two
three
Completed...
*/
</code></pre>

<p>O <code>Observable</code> possui muitos métodos de fábrica que podem ser utilizados para criação. O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a> utilizado nos exemplos acima cria um Observable a partir de uma sequência fixa de valores; podemos utilizar também um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">intervalo de valores</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">intervalo de tempo</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">Callable</a>, um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromFuture-java.util.concurrent.Future-">Future</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromPublisher-org.reactivestreams.Publisher-">outro Observable</a>&hellip;veremos todos esses métodos em detalhes no decorrer do post.</p>

<h2 id="completable-single-maybe">Completable, Single, Maybe</h2>

<p>Na versão 2 do RxJava, existem algumas especializações interessantes sobre o comportamento de um fluxo reativo. Eventualmente, queremos nos sobrescrever a um objeto observável com uma semântica diferente de um <code>Observable</code> convencional; às vezes esse objeto não irá emitir valores (ou emitirá um erro ou apenas completará), ou emitirá apenas um valor, ou <em>talvez</em> emita apenas um valor (ou nenhum). Existem alguns objetos específicos para essas situações.</p>

<h3 id="completable">Completable</h3>

<p><a href="http://reactivex.io/RxJava/javadoc/">Completable</a> representa um computação que <strong>não devolve valores</strong>, podendo gerar um erro ou ser concluída sem erros. Um <code>Completable</code>, então, nunca irá emitir o evento <em>onNext</em>; apenas <em>onCompleted</em> ou <em>onError</em>.</p>

<pre><code class="language-java">Completable completable = Completable.complete();

completable.subscribe(() -&gt; System.out.println(&quot;Completed...&quot;));

/*
output:

Completed...
*/
</code></pre>

<pre><code class="language-java">Completable completable = Completable.error(new RuntimeException(&quot;oops...&quot;));

completable.subscribe(() -&gt; System.out.println(&quot;Completed...&quot;), Throwable::printStackTrace); //o segundo parâmetro é a ação que deverá ser realizada em caso de erro (um Consumer que recebe um Throwable)

/*
output:

java.lang.RuntimeException: oops...
*/
</code></pre>

<p>E para o que poderia servir isso? Talvez para algo assim:</p>

<pre><code class="language-java">Completable completable = Completable.fromAction(() -&gt; {
	/* aqui você poderia executar alguma ação como invocar uma API externa, persistir alguma informação, etc.
	   ou qualquer outra tarefa onde você não precisa de algum valor de retorno,
	   mas precisa reagir caso ocorra algum erro ou quando essa ação seja concluída
	*/
});

completable.subscribe(() -&gt; System.out.println(&quot;Ok...a ação terminou sem erros.&quot;), Throwable::printStackTrace);
</code></pre>

<h3 id="single">Single</h3>

<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html">Single</a> é um objeto que pode emitir <strong>apenas um valor</strong>, ou um erro. Um <code>Single</code> não emite o evento <em>onCompleted</em>, pois o fato de emitir o <em>onNext</em> apenas uma vez indica de maneira implícita que o <code>Single</code> foi &ldquo;completado&rdquo;.</p>

<pre><code class="language-java">Single&lt;String&gt; single = Single.just(&quot;one&quot;);

single.subscribe(System.out::println);

/*
output:

one
*/
</code></pre>

<pre><code class="language-java">Single&lt;String&gt; single = Single.error(new RuntimeException(&quot;oops...&quot;));

single.subscribe(System.out::println, Throwable::printStackTrace);
/*
output:

java.lang.RuntimeException: oops...
*/
</code></pre>

<h3 id="maybe">Maybe</h3>

<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Maybe.html">Maybe</a> é um objeto que <strong>pode</strong> emitir um valor, mas que talvez não emita nenhum. Caso esse valor exista, esse objeto emitirá um evento diferente chamado <em>onSuccess</em>; se não, poderá emitir os eventos <em>onError</em> ou <em>onCompleted</em>. Esses eventos são <strong>excludentes</strong>; se o <em>onSucess</em> for disparado, o <code>Maybe</code> será implicitamente completado (o <em>onError</em> tem a mesma semântica); se o <code>Maybe</code> não emitir nenhum valor apenas o <em>onCompleted</em> será disparado.</p>

<pre><code class="language-java">Maybe&lt;String&gt; maybe = Maybe.just(&quot;any value&quot;);

maybe.subscribe(System.out::println); //onSuccess

/*
output:

any value
*/
</code></pre>

<pre><code class="language-java">Maybe&lt;String&gt; maybe = Maybe.error(new RuntimeException(&quot;oops...&quot;));

maybe.subscribe(System.out::println, Throwable::printStackTrace);

/*
output:

java.lang.RuntimeException: oops...
*/
</code></pre>

<pre><code class="language-java">Maybe&lt;String&gt; maybe = Maybe.empty();

maybe.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;Completed...&quot;));

/*
output:

Completed...
*/
</code></pre>

<pre><code class="language-java">/* Esse exemplo demonstra bem a diferença entre um Maybe e um Observable.
   Aqui, estamos criando o Maybe a partir de uma computação que devolve null.
   Nessa situação, o Maybe irá emitir o evento onCompleted, pois não há valor a ser emitido para o onSuccess.
   Já um Observable nunca emite valores nulos (o código abaixo lançaria uma exceção, se fosse um Observable).
*/

Maybe&lt;String&gt; maybe = Maybe.fromCallable(() -&gt; null);

maybe.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;Completed...&quot;));

/*
output:

Completed...
*/
</code></pre>

<h2 id="ciclo-de-vida-de-um-subscriber">Ciclo de vida de um Subscriber</h2>

<p>Nos exemplos acima, nosso código se subscreve às fontes de eventos reativos (<code>Observable</code>, <code>Completable</code>, etc) e reage conforme as coisas acontecem. Como vimos no post anterior, o ato de vincular um <em>Subscriber</em> a um fluxo de dados é chamado de <strong>subscription</strong>. Na versão 1.x, o RxJava possuía um objeto chamado <a href="http://reactivex.io/RxJava/1.x/javadoc/rx/Subscription.html">Subscription</a> para representar esse conceito, e esse objeto era responsável pelo ciclo de vida de uma subscrição. Na versão 2.x, essa classe foi renomeada para <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/Disposable.html">Disposable</a>.</p>

<p>Eventualmente, um comportamento que podemos desejar é <strong>cancelar</strong> uma subscrição; podemos fazer isso facilmente. No exemplo abaixo, um <code>Observable</code> é criado a partir do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#interval-long-java.util.concurrent.TimeUnit-">interval</a>; esse método cria um <code>Observable</code> que emite um valor do tipo <code>Long</code> a cada intervalo de tempo:</p>

<pre><code class="language-java">Observable&lt;Long&gt; observable = Observable.interval(1000, TimeUnit.MILLISECONDS);

observable.subscribe(System.out::println);

Thread.sleep(5000);

/*
output:

0
1
2
3
4
*/
</code></pre>

<p>O método <code>subscribe</code> devolve um <code>Disposable</code>, que podemos utilizar para cancelar a subscrição:</p>

<pre><code class="language-java">Observable&lt;Long&gt; observable = Observable.interval(1000, TimeUnit.MILLISECONDS);

Disposable subscription = observable.subscribe(System.out::println);

Thread.sleep(2000);

subscription.dispose(); //o método dispose cancela a subscrição; os eventos emitidos a partir daqui já não serão capturados por esse objeto

Thread.sleep(3000);

/*
output:

0
1
*/
</code></pre>

<h2 id="posso-ter-mais-de-um-subscriber">Posso ter mais de um subscriber?</h2>

<p>Sim! Você pode vincular ao <code>Observable</code> quantos <em>subscribers</em> desejar (o mesmo se aplica ao <code>Completable</code>, <code>Single</code> e <code>Maybe</code>). Isso pode trazer uma questão cuja resposta pode não ser tão óbvia: digamos que criamos um <code>Observable</code> a partir de uma lista de valores finitos (como os exemplos acima), nos subscrevemos e recebemos todos os eventos <em>onNext</em> e depois o <em>onCompleted</em>, que é um evento <strong>terminal</strong>; o que acontece se fizemos outra subscrição após esse evento?</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;Completed...&quot;));

/*
output:

one
two
three
Completed...
*/
</code></pre>

<p>Se adicionarmos um novo <em>subscriber</em>:</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;Completed...&quot;));

observable.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v));

/*
output:

one
two
three
Completed...
Second subscriber: one
Second subscriber: two
Second subscriber: three
*/
</code></pre>

<p>A sequência de eventos foi re-executada quando o segundo <em>subscription</em> foi realizado. Com efeito, mesmo em relação ao primeiro <em>subscriber</em>, os eventos só foram enviados <strong>após</strong> a subscrição ter sido realizada, o que nos leva a concluir: até você se subscrever, <strong>nada acontece</strong>.</p>

<p>Mas será que sempre vamos desejar esse comportamento? E se nosso Observable fosse gerado a partir de um fluxo assíncrono e potencialmente infinito (digamos, um <em>stream</em> do Twitter), e quiséssemos que novos <em>subscribers</em> ouvissem os eventos gerados <strong>a partir do momento em que eles se subscreveram</strong>, seria possível?</p>

<h3 id="observables-frios-e-quentes">Observables &ldquo;frios&rdquo; e &ldquo;quentes&rdquo;</h3>

<p>Nos frameworks Rx, existem dois &ldquo;sabores&rdquo; de Observables, chamados <strong>cold</strong> (frios) e <strong>hot</strong> (quentes). O comportamento que vimos acima é de um <code>Observable</code> frio; a sequência de eventos é executada <strong>apenas quando e se o Observable tenha algum subscriber associado</strong>, e o fluxo de eventos é executado para cada subscrição realizada. O exemplo abaixo (novamente usando o método <code>interval</code>) demonstra bem esse funcionamento:</p>

<pre><code class="language-java">Observable&lt;Long&gt; observable = Observable.interval(1000, TimeUnit.MILLISECONDS);

observable.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v));

Thread.sleep(2000);

observable.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v));

Thread.sleep(2000);

/*
output:

First subscriber: 0
First subscriber: 1
First subscriber: 2
Second subscriber: 0
First subscriber: 3
Second subscriber: 1
...
*/
</code></pre>

<p>Os dois <em>subscribers</em> não recebem os mesmos valores ao mesmo tempo, embora ambos estejam vinculados ao mesmo <code>Observable</code>. Eles recebem <strong>a mesma sequência de eventos</strong>, com a diferença que o &ldquo;início&rdquo; dos eventos para cada um se dará a partir do momento da subscrição.</p>

<p>Todo <code>Observable</code> criado a partir do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#create-io.reactivex.ObservableOnSubscribe-">create</a> é um &ldquo;cold observable&rdquo;, incluindo todos os métodos auxiliares como <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">range</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">timer</a>, <code>from*</code>(<a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromArray-T...-">fromArray</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">fromCallable</a>, etc) e o próprio <code>interval</code> do exemplo acima.</p>

<p>Um &ldquo;hot observable&rdquo; tem um comportamento diferente; ele emite eventos <strong>independente de haver algum subscriber associado</strong>. É possível converter um &ldquo;cold observable&rdquo; em &ldquo;hot observable&rdquo; usando o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#publish--">publish</a>, que devolve um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/ConnectableObservable.html">ConnectableObservable</a>, um tipo especial de <code>Observable</code> que passa a emitir sequências após a invocação do método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/ConnectableObservable.html#connect--">connect</a>, havendo <em>subscribers</em> ou não. O código a seguir demonstra essa lógica:</p>

<pre><code class="language-java">Observable&lt;Long&gt; observable = Observable.interval(1000, TimeUnit.MILLISECONDS); //emite um valor a cada segundo: 0, 1, 2...

ConnectableObservable&lt;Long&gt; hot = observable.publish(); //o método publish devolve o ConnectableObservable
hot.connect(); //aqui a sequência de eventos será iniciada

Thread.sleep(3000); //aguarda três segundos; nesse intervalo o Observable já terá emitido os valores 0, 1, e 2

hot.subscribe(System.out::println); //esse subscriber será notificado a partir do valor 3 da sequência

Thread.sleep(3000); //aguarda por mais três segundos...

/*
output:

3
4
5
*/
</code></pre>

<p>O método <code>connect</code> também devolve um <code>Disposable</code>, que poderia ser usado eventualmente para cancelar a emissão de eventos.</p>

<h2 id="subjects">Subjects</h2>

<p>Um objeto reativo muito interessante é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/Subject.html">Subject</a>. Essa classe implementa a interface <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observer.html">Observer</a>, portanto pode <strong>ouvir</strong> eventos; também extende <code>Observable</code>, portanto, pode <strong>enviar</strong> eventos (ou reemitir).</p>

<p>Um <code>Subject</code> é ideal como &ldquo;porta de entrada&rdquo; para o mundo Rx, pois permite que você &ldquo;empurre&rdquo; valores para um <em>pipeline</em> reativo mesmo que tais valores sejam gerados fora do RxJava (lembre-se que o conceito de dados &ldquo;empurrados&rdquo; (push) é fundamental para a programação reativa).</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

PublishSubject&lt;String&gt; subject = PublishSubject.create(); //spoiler :)...mais informações daqui a pouco!
subject.subscribe(System.out::println); //podemos nos subscrever ao Subject

observable.subscribe(subject); //podemos usar o Subject para nos subscrevermos a outros Observables

/*
output:

one
two
three
*/
</code></pre>

<p>No RxJava, o <code>Subject</code> tem várias implementações diferentes. Vamos analisar cada uma delas.</p>

<h3 id="publishsubject">PublishSubject</h3>

<p>Um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/PublishSubject.html">PublishSubject</a> emite eventos para o observador apenas a partir do instante em que a subscrição é realizada.</p>

<pre><code class="language-java">PublishSubject&lt;String&gt; subject = PublishSubject.create();

// o primeiro subscriber
subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v));

// emite dois eventos
subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

// o segundo subscriber
subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v));

//emite outro evento
subject.onNext(&quot;three&quot;);

/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
Second subscriber: three
*/
</code></pre>

<p>Se ocorrer um evento terminal (<em>onCompleted</em> ou <em>onError</em>) os <em>subscribers</em> posteriores receberão apenas este evento:</p>

<pre><code class="language-java">PublishSubject&lt;String&gt; subject = PublishSubject.create();

subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

// emite o evento onCompleted
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));

/*
output:

First subscriber: one
First subscriber: two
OnComplete to first subscriber
OnComplete to second subscriber
*/
</code></pre>

<h3 id="replaysubject">ReplaySubject</h3>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html">ReplaySubject</a> emite todos os valores para todos os <em>subscribers</em>, independente do momento em que a subscrição foi feita.</p>

<pre><code class="language-java">ReplaySubject&lt;String&gt; subject = ReplaySubject.create();

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);
subject.onNext(&quot;three&quot;);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));
subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));

/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: one
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/
</code></pre>

<p>Armazenar todos os valores indefinidamente pode não ser o ideal. O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html#createWithSize-int-">createWithSize</a> permite estabelecer um limite para o <em>buffer</em>:</p>

<pre><code class="language-java">ReplaySubject&lt;String&gt; subject = ReplaySubject.createWithSize(2);

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);
subject.onNext(&quot;three&quot;);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));
subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));

/*
output:

First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/
</code></pre>

<p>Também é possível estabeler um limite de armazenamento baseado no tempo decorrido, com o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/ReplaySubject.html#createWithTime-long-java.util.concurrent.TimeUnit-io.reactivex.Scheduler-">createWithTime</a>. Além dos parâmetros de tempo, esse método recebe um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Scheduler.html">Scheduler</a>; para evitar <em>spoilers</em>, não entrarei em detalhes agora desse importantíssimo objeto mas falaremos dele em detalhes no próximo post :).</p>

<p>O <code>Observable</code> tem um método chamado <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#replay--">replay</a>, que tem um comportamento equivalente.</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

ConnectableObservable&lt;String&gt; hot = observable.replay();
hot.connect();

hot.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));
hot.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));

/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
OnComplete to first subscriber
Second subscriber: one
Second subscriber: two
Second subscriber: three
OnComplete to second subscriber
*/
</code></pre>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#cache--">cache</a> também tem um comportamento semelhante, pois armazena todos os valores emitidos, mas não permite o gerenciamento do ciclo de vida das subscrições.</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

// o método cache não devolve um ConnectableObservable, ao contrário do método replay;
// isso significa que não podemos usar o Disposable obtido após a chamada do método ConnectableObservable.connect
Observable&lt;String&gt; cached = observable.cache();

cached.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));
cached.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));
</code></pre>

<h3 id="behaviorsubject">BehaviorSubject</h3>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/BehaviorSubject.html">BehaviorSubject</a> emite o item mais recente e todos os subsequentes, a partir do momento da subscrição.</p>

<pre><code class="language-java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.create();

subject.onNext(&quot;one&quot;);
subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v));

subject.onNext(&quot;two&quot;);
subject.onNext(&quot;three&quot;);

subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v));

subject.onNext(&quot;four&quot;);

/*
output:

First subscriber: one
First subscriber: two
First subscriber: three
Second subscriber: three
First subscriber: four
Second subscriber: four
*/
</code></pre>

<p>Se ocorrer um evento terminal (<em>onCompleted</em> ou <em>onError</em>) os <em>subscribers</em> posteriores receberão apenas este evento:</p>

<pre><code class="language-java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.create();

subject.onNext(&quot;one&quot;);
subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to first subscriber&quot;));

subject.onNext(&quot;two&quot;);
subject.onComplete();

subject.subscribe(v -&gt; System.out.println(&quot;Second subscriber: &quot; + v), Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnComplete to second subscriber&quot;));

/*
output:

First subscriber: one
First subscriber: two
OnComplete to first subscriber
OnComplete to second subscriber
*/
</code></pre>

<p>Uma motivação comum para utilizar o <code>BehaviorSubject</code> é a necessidade de sempre ter um valor disponível para a leitura, mesmo que seja um valor padrão ou um <em>null object</em>. É possível inicializar esse objeto com um valor <em>default</em>:</p>

<pre><code class="language-java">BehaviorSubject&lt;String&gt; subject = BehaviorSubject.createDefault(&quot;one&quot;);

subject.subscribe(v -&gt; System.out.println(&quot;First subscriber: &quot; + v));
</code></pre>

<h3 id="asyncsubject">AsyncSubject</h3>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/AsyncSubject.html">AsyncSubject</a> também armazena o último valor, mas só o emite após a ocorrência de um evento terminal.</p>

<pre><code class="language-java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println);

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);
subject.onNext(&quot;three&quot;);
</code></pre>

<p>No exemplo acima, nenhuma saída é gerada, porque não houve nenhum evento terminal (<em>onCompleted</em> ou <em>onError</em>). Vejamos a diferença quando isso ocorre:</p>

<pre><code class="language-java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println);

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.onComplete(); //onCompleted emitido -&gt; o último valor emitido pelo onNext será enviado ao subscriber

/*
output:

two
*/
</code></pre>

<pre><code class="language-java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.subscribe(System.out::println, Throwable::printStackTrace);

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.onError(new RuntimeException(&quot;ooops&quot;)); //onError emitido -&gt; apenas esse erro será enviado ao subscriber (o último valor não)

/*
output:

java.lang.RuntimeException: ooops
*/
</code></pre>

<p>A emissão de valores para os <em>subscribers</em> subsequentes seguirá a mesma semântica: se o evento terminal foi o <em>onCompleted</em>, o <em>subscriber</em> mais recente receberá o último <em>onNext</em> e o <em>onCompleted</em>; se o evento terminal foi o <em>onError</em>, o <em>subscriber</em> mais recente receberá apenas o erro.</p>

<pre><code class="language-java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.onComplete();

subject.subscribe(System.out::println, Throwable::printStackTrace, () -&gt; System.out.println(&quot;OnCompleted&quot;));

/*
output:

two
OnCompleted
*/
</code></pre>

<pre><code class="language-java">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.onError(new RuntimeException(&quot;ooops&quot;));

subject.subscribe(System.out::println, Throwable::printStackTrace);

/*
output:

java.lang.RuntimeException: ooops
*/
</code></pre>

<h3 id="unicastsubject">UnicastSubject</h3>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/UnicastSubject.html">UnicastSubject</a> é um <code>Subject</code> que permite <strong>apenas um subscriber</strong> associado. Os eventos são armazenados em uma pilha interna, assim como na implementação do <code>ReplaySubject</code>, mas ao contrário deste, o <em>buffer</em> do <code>UnicastSubject</code> é <strong>ilimitado</strong>, sendo esvaziado apenas quando um evento terminal ocorre ou o <em>subscriber</em> é desassociado (pelo método <code>Dispose.dispose()</code>).</p>

<pre><code class="language-java">UnicastSubject&lt;String&gt; subject = UnicastSubject.create();

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.subscribe(System.out::println);

/*
output:

one
two
*/
</code></pre>

<p>Como dissemos, o <code>UnicastSubject</code> permite apenas um <em>subscriber</em>. Eis o que ocorre se tentarmos associar um segundo ouvinte de eventos:</p>

<pre><code class="language-java">UnicastSubject&lt;String&gt; subject = UnicastSubject.create();

subject.onNext(&quot;one&quot;);
subject.onNext(&quot;two&quot;);

subject.subscribe(System.out::println, Throwable::printStackTrace);
subject.subscribe(System.out::println, Throwable::printStackTrace);

/*
output:

one
two
java.lang.IllegalStateException: Only a single observer allowed. //exceção indicando que não é permitido mais de um observer
*/
</code></pre>

<p>Mais informações sobre <code>Subjects</code> podem ser encontradas na documentação do <a href="http://reactivex.io/documentation/subject.html">ReactiveX</a>.</p>

<h2 id="operadores-reativos">Operadores reativos</h2>

<p>A programação reativa é um paradigma que opera sobre <strong>fluxos de dados observáveis</strong>, e temos objetos que representam um <em>stream</em> (Observable e etc) e outros objetos que nos permitem observar o fluxo (os <em>subscribers</em>). Mas, mais do que apenas observar, também desejamos operar, filtrar, interagir, e modificar esses dados, e os frameworks que implementam o paradigma reativo fornecem uma fantástica caixa de ferramentas para esse propósito: os <a href="http://reactivex.io/documentation/operators.html">operadores reativos</a>, uma enorme quantidade de métodos e operações que efetivamente fazem a mágica acontecer. É importante relembrar que os operadores <strong>não modificam o fluxo de dados</strong>, pois um dos fundamentos da programação reativa é a <strong>propagação de estado</strong>; portanto, todos os operadores criam novos objetos imutáveis, com efeito, propagando o novo estado (o dado modificado) para o novo <em>stream</em>.</p>

<h3 id="marble-diagrams">Marble diagrams</h3>

<p>O comportamento dos métodos reativos são demonstrados visualmente na documentação do Rx usando &ldquo;marble diagrams&rdquo;, que demonstram uma <strong>sequência de eventos ordenados no tempo</strong>, que é o conceito principal que os objetos reativos representam. Uma explicação rápida dos conceitos nesse diagrama pode nos ser útil antes de nos aprofundarmos nesses métodos.</p>

<p>Essa é uma simples linha do tempo, sobre a qual os eventos ocorrem:</p>

<p><img src="/images/programacao-reativa-parte-2-1.png" alt="Uma linha do tempo" /></p>

<p>Os elementos emitidos são representados por figuras geométricas. Na imagem abaixo, três itens são emitidos e o <code>stream</code> é completado (três eventos <em>onNext</em> e o evento <em>onCompleted</em>, portanto). A linha vertical representa o <em>onCompleted</em>.</p>

<p><img src="/images/programacao-reativa-parte-2-2.png" alt="Três itens emitidos e o evento onCompleted" /></p>

<p>Abaixo, três itens são emitidos, seguidos de um erro (três eventos <em>onNext</em> e o evento <em>onError</em>). O &ldquo;X&rdquo; representa o <em>onError</em>.</p>

<p><img src="/images/programacao-reativa-parte-2-3.png" alt="Três itens emitidos e o evento onError" /></p>

<p>Juntando tudo, uma operação reativa completa sobre a linha do tempo seria representada da seguinte forma:</p>

<p><img src="/images/programacao-reativa-parte-2-4.png" alt="Marble diagram completo" /></p>

<p>Um <em>site</em> que demonstra esses diagramas de forma simples é o <a href="http://rxmarbles.com/">RxMarbles</a>, que utilizo bastante. No decorrer do post, vou utilizar diagramas retirados da documentação do RxJava para demonstrar o comportamento de cada operador.</p>

<h3 id="métodos-com-efeitos-colaterais">Métodos com efeitos colaterais</h3>

<p>Antes de falarmos dos operadores (que são, com efeito, os principais métodos dos frameworks Rx), é importante conhecer os <a href="http://reactivex.io/documentation/operators/do.html">side-effect methods</a>: os métodos <em>do</em>. Esses métodos não modificam os dados (não trabalham com a <em>propagação de estado</em> do fluxo) e não criam novos <code>streams</code>, pois foram concebidos para efetivamente gerar efeitos colaterais durante a emissão de eventos. Dado que o <code>Observable</code> (e os outros) são objetos imutáveis, esses métodos não afetam o seu estado, mas permitem associar comportamentos <strong>quando determinados eventos ocorrerem</strong>; como operam apenas sobre os eventos, e não sobre o <code>pipeline</code> de transformação do <code>stream</code>, funcionam como <em>hooks</em> ou <em>callbacks</em> da ocorrência de cada evento, permitindo realizar ações muito específicas. São muito úteis para <em>logging</em> e depuração.</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

observable
	.doOnSubscribe(d -&gt; System.out.println(&quot;DoOnSubscribe: &quot; + d)) 		// quando um subscriber se registra
	.doOnEach(v -&gt; System.out.println(&quot;DoOnEach:&quot; + v))					// quando ocorre qualquer evento; o parâmetro é um objeto do tipo Notification
	.doOnNext(v -&gt; System.out.println(&quot;DoOnNext: &quot; + v))				// quando ocorre o evento onNext
	.doOnError(t -&gt; System.out.println(&quot;DoOnError: &quot; + t))				// quando ocorre o evento onError
	.doOnComplete(() -&gt; System.out.println(&quot;DoOnComplete&quot;))				// quando ocorre o evento onComplete
	.doAfterNext(v -&gt; System.out.println(&quot;DoAfterNext: &quot; + v))			// após a ocorrência do evento onNext
	.doOnTerminate(() -&gt; System.out.println(&quot;DoOnTerminate&quot;))			// quando ocorre um evento terminal
	.doAfterTerminate(() -&gt; System.out.println(&quot;DoAfterTerminate&quot;))		// após a ocorrência de um evento terminal
	.doFinally(() -&gt; System.out.println(&quot;DoFinally&quot;))					// quando ocorre um evento terminal, ou quando um subscriber se desvincula do stream
	.subscribe(); // os callbacks acima são invocados para cada subscriber

/*
output:
DoOnSubscribe: io.reactivex.internal.observers.DisposableLambdaObserver@57fffcd7
DoOnEach:OnNextNotification[one]
DoOnNext: one
DoAfterNext: one
DoOnEach:OnNextNotification[two]
DoOnNext: two
DoAfterNext: two
DoOnEach:OnNextNotification[three]
DoOnNext: three
DoAfterNext: three
DoOnEach:OnCompleteNotification
DoOnComplete
DoOnTerminate
DoFinally
DoAfterTerminate
*/
</code></pre>

<p>Novamente, é importante destacar que nenhum dos métodos acima representa uma subscrição, e sim <em>callbacks</em> específicos para cada evento.</p>

<h3 id="agora-sim-operadores-reativos">Agora, sim: operadores reativos!</h3>

<p>No caso do RxJava, que estamos utilizando aqui, o <code>Observable</code> possui <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html">dezenas de métodos</a> (sim, dezenas), e seria cansativo detalhar todos aqui. Vamos ver algumas demonstrações dos operadores que considero mais úteis e interessantes.</p>

<h3 id="criação">Criação</h3>

<h4 id="create">create</h4>

<p><img src="/images/programacao-reativa-parte-2-5.png" alt="create" /></p>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html">create</a> é uma maneira simples de criar um <em>cold observable</em>. Ele recebe como parâmetro um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableOnSubscribe.html">ObservableOnSubscribe</a>, que pode ser representado como uma função que recebe um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableEmitter.html">ObservableEmitter</a>, um objeto que permite emitir eventos explicitamente.</p>

<pre><code class="language-java">Observable&lt;String&gt; observable = Observable.create(e -&gt; e.onNext(&quot;hello&quot;));

observable.subscribe(System.out::println);

/*
output:

hello
*/
</code></pre>

<h4 id="defer">defer</h4>

<p><img src="/images/programacao-reativa-parte-2-6.png" alt="defer" /></p>

<p>No exemplo acima, o <code>ObservableOnSubscribe</code> será invocado para cada subscrição realizada (um <em>cold observable</em>, portanto). Podemos ter algum caso de uso onde queremos gerar <strong>preguiçosamente</strong> os valores emitidos, e o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#defer-java.util.concurrent.Callable-">defer</a> permite fornecer uma fábrica (representada por um <code>Callable</code>) para a criação do <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableSource.html">ObservableSource</a>, que será executado a cada subscrição.</p>

<pre><code class="language-java">// a diferença aqui é que o parâmetro representa um função que devolve um ObservableSource,
// que pode ser gerado de maneira &quot;lazy&quot;
Observable&lt;String&gt; observable = Observable.defer(() -&gt; Observable.just(&quot;one&quot;, &quot;two&quot;));

observable.subscribe(System.out::println);

/*
output:

one
two
*/
</code></pre>

<h4 id="empty-never-error">empty, never, error</h4>

<p><img src="/images/programacao-reativa-parte-2-7.png" alt="empty" /></p>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#empty--">empty</a> devolve um <code>Observable</code> que não emite nenhum valor, e emite imediatamente o evento <em>onCompleted</em> quando ocorre um subscrição:</p>

<pre><code class="language-java">Observable.empty()
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

/*
output:

OnComplete
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-8.png" alt="never" /></p>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#never--">never</a> devolve um <code>Observable</code> que nunca notifica nenhum <em>subscriber</em>. Isso é útil para ser utilizado como <em>null object</em>.</p>

<pre><code class="language-java">// nenhuma saída é gerada para o código abaixo
Observable.never()
		.doOnNext(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

</code></pre>

<p><img src="/images/programacao-reativa-parte-2-9.png" alt="error" /></p>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#error-java.lang.Throwable-">error</a> devolve um <code>Observable</code> que imediatamente emite o evento <em>onError</em>. Também há uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#error-java.util.concurrent.Callable-">sobrecarga</a> desse método que recebe um <code>Callable</code>, permitindo gerar a exceção de maneira <em>lazy</em>.</p>

<pre><code class="language-java">Observable.error(new RuntimeException(&quot;ooops...&quot;))
		.subscribe(System.out::println, Throwable::printStackTrace);

/*
output:

java.lang.RuntimeException: ooops...
*/
</code></pre>

<h4 id="from">from</h4>

<p>Existe uma variedade de métodos <em>from</em>: <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromArray-T...-">fromArray</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromCallable-java.util.concurrent.Callable-">fromCallable</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromFuture-java.util.concurrent.Future-">fromFuture</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromIterable-java.lang.Iterable-">fromIterable</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#fromPublisher-org.reactivestreams.Publisher-">fromPublisher</a>: a motivação desses métodos é converter outros tipos de objetos e estruturas de dados para um <code>Observable</code>.</p>

<h4 id="just">just</h4>

<p><img src="/images/programacao-reativa-parte-2-10.png" alt="just" /></p>

<p>Utilizado em praticamente todos os exemplos desse post, o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#just-T-">just</a> simplesmente cria um <code>Observable</code> a partir de uma lista de valores, emitindo todos através do evento <em>onNext</em>.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
two
three
*/
</code></pre>

<h4 id="range">range</h4>

<p><img src="/images/programacao-reativa-parte-2-11.png" alt="range" /></p>

<p>O método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#range-int-int-">range</a> devolve um <code>Observable</code> que emite uma sequência de valores do tipo <code>Integer</code> dentro do intervalo especificado (há outro operador que emite valores do tipo <code>Long</code>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#rangeLong-long-long-">rangeLong</a>) .</p>

<pre><code class="language-java">Observable.range(0, 5)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

0
1
2
3
4
*/
</code></pre>

<h4 id="interval-e-timer">interval e timer</h4>

<p><img src="/images/programacao-reativa-parte-2-12.png" alt="interval" /></p>

<p>O método <a href="interval">interval</a> devolve um <code>Observable</code> que emite um valor do tipo <code>Long</code> a cada intervalo de tempo especificado. Há uma sobrecarga em que é possível configurar um <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#interval-long-long-java.util.concurrent.TimeUnit-">delay inicial</a>.</p>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
		.doOnNext(System.out::println)
		.subscribe();


Thread.sleep(5000);

/*
output:

0
1
2
3
4
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-13.png" alt="timer" /></p>

<p>Já com o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timer-long-java.util.concurrent.TimeUnit-">timer</a>, o <code>Observable</code> criado irá emitir o valor 0 (<code>Long</code>) após o intervalo de tempo especificado, e depois o evento <em>onCompleted</em>.</p>

<pre><code class="language-java">Observable.timer(1000, TimeUnit.MILLISECONDS)
		.doOnNext(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;Completed&quot;))
		.subscribe();

Thread.sleep(1500);

/*
output:

0
Completed
*/
</code></pre>

<h3 id="transformação">Transformação</h3>

<h4 id="map">map</h4>

<p><img src="/images/programacao-reativa-parte-2-14.png" alt="map" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#map-io.reactivex.functions.Function-">map</a> devolve um <code>Observable</code> que aplica uma função de transformação para cada item emitido, e então emite os novos valores.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.map(value -&gt; &quot;Hello, i'm &quot; + value) //lembrete importante: o retorno desse operador é um novo Observable (do tipo retornado pela função)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

Hello, i'm one
Hello, i'm two
Hello, i'm three
*/
</code></pre>

<h4 id="flatmap">flatMap</h4>

<p><img src="/images/programacao-reativa-parte-2-15.png" alt="flatMap" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#flatMap-io.reactivex.functions.Function-">flatMap</a> devolve um <code>Observable</code> que, para cada item, aplica uma função de transformação <strong>que devolve um novo Observable</strong>; todos os novos <code>Observables</code> gerados para cada chamada da função são então mergeados e &ldquo;achatados&rdquo; (essa operação se chama <em>flattern</em>) em um novo <code>Observable</code>.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.flatMap(value -&gt; Observable.just(&quot;Hello, i'm &quot; + value))
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

Hello, i'm one
Hello, i'm two
Hello, i'm three
*/
</code></pre>

<h4 id="timestamp">timestamp</h4>

<p><img src="/images/programacao-reativa-parte-2-16.png" alt="timestamp" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#timestamp--">timestamp</a> encapsula cada item emitido em um objeto do tipo <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/schedulers/Timed.html">Timed</a>, contendo o <em>timestamp</em> do momento em que o <em>onNext</em> ocorreu e o valor.</p>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
	.timestamp()
	.map(t -&gt; &quot;Timestamp: &quot; + t.time() + &quot;, and value: &quot; + t.value())
	.subscribe(System.out::println);

Thread.sleep(5000);

/*
output:

Timestamp: 1523914485689, and value: 0
Timestamp: 1523914486689, and value: 1
Timestamp: 1523914487689, and value: 2
Timestamp: 1523914488691, and value: 3
Timestamp: 1523914489692, and value: 4
*/
</code></pre>

<h3 id="agregação-e-acumulação">Agregação e acumulação</h3>

<h4 id="groupby">groupBy</h4>

<p><img src="/images/programacao-reativa-parte-2-17.png" alt="groupBy" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#groupBy-io.reactivex.functions.Function-">groupBy</a> permite o agrupamento de valores emitidos a partir do critério implementado na função, e devolve um <code>Observable</code> que emite valores do tipo <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/observables/GroupedObservable.html">GroupedObservable</a>; o retorno da função será a chave de agrupamento que pode ser recuperada em cada <code>GroupedObservable</code>. Esse objeto também é um <code>Observable</code>, então podemos nos subscrever nele para obter os valores do grupo.</p>

<pre><code class="language-java">Observable.range(0, 10)
		.groupBy(value -&gt; value % 2 == 0 ? &quot;even&quot; : &quot;odd&quot;) // &quot;even&quot; ou &quot;odd&quot; serão as chaves de agrupamento; são avaliadas para cada valor emitido
		.subscribe(group -&gt; {

			// group é do tipo GroupedObservable
			group.subscribe(value -&gt; System.out.println(&quot;Group &quot; + group.getKey() + &quot; and value &quot; + value));

		});

/*
output:

Group even and value 0
Group odd and value 1
Group even and value 2
Group odd and value 3
Group even and value 4
Group odd and value 5
Group even and value 6
Group odd and value 7
Group even and value 8
Group odd and value 9
*/
</code></pre>

<h4 id="buffer">buffer</h4>

<p><img src="/images/programacao-reativa-parte-2-18.png" alt="buffer" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#buffer-int-">buffer</a> coleta os items emitidos baseado em um parâmetro de quantidade de elementos ou tempo transcorrido, e gera um novo <code>Observable</code> com um <code>List</code> dos valores bufferizados.</p>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
	.buffer(2) //buffer a cada dois elementos emitidos
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output:

[0, 1] // um valor do tipo java.util.List é emitido no onNext
[2, 3]
[4, 5]
[6, 7]
[8, 9]
*/
</code></pre>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
	.buffer(2000, TimeUnit.MILLISECONDS) // buffer a cada dois segundos
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output: // essa saída pode ter variacões

[0, 1]
[2, 3]
[4, 5]
[6, 7]
[8, 9]
*/
</code></pre>

<h4 id="reduce">reduce</h4>

<p><img src="/images/programacao-reativa-parte-2-19.png" alt="reduce" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#reduce-io.reactivex.functions.BiFunction-">reduce</a> aplica uma função de acumulação sobre o conjunto de items emitidos pelo <code>Observable</code>; a função é aplicada ao primeiro valor, e o retorno é reenviado à mesma função com o segundo valor, e assim sucessivamente, reduzindo o conjunto a um único valor final. Essa operação é chamada no RxJava de &ldquo;reduce&rdquo; (nome mais comum), mas também é conhecida como &ldquo;fold&rdquo; (mais comum em linguagens funcionais), &ldquo;accumulate&rdquo;, &ldquo;aggregate&rdquo;, dependendo do contexto. É importante observar que esse operador só pode gerar um valor de retorno após o evento <em>onCompleted</em> do <code>Observable</code> original, então essa operação é mais convenientemente aplicada em <code>streams</code> finitos. Um <code>Observable</code> infinito pode nunca emitir o <em>onCompleted</em>, podendo gerar um <code>OutOfMemoryError</code> pelo acúmulo de valores.</p>

<p>O parâmetro desse operador é um <code>BiFunction</code>, uma interface funcional do Java que representa uma função com dois argumentos e retorna um valor qualquer. O retorno é do tipo <code>Maybe</code>.</p>

<pre><code class="language-java">Observable.range(1, 10)
		.doOnNext(System.out::println) // imprime cada valor emitido no range
		.reduce((a, b) -&gt; a + b) //soma todos os valores emitidos no range
		.doOnSuccess(r -&gt; System.out.println(&quot;Reduce: &quot; + r))
		.subscribe();

/*
output:

1
2
3
4
5
6
7
8
9
10
Reduce: 55
*/
</code></pre>

<p>Existe uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#reduce-R-io.reactivex.functions.BiFunction-">sobrecarga</a> que permite passar à função um valor inicial:</p>

<pre><code class="language-java">Observable.range(1, 10)
		.doOnNext(System.out::println)
		.reduce(100, (a, b) -&gt; a + b) //100 é o valor inicial passado à função
		.doOnSuccess(r -&gt; System.out.println(&quot;Reduce: &quot; + r))
		.subscribe();

/*
output:

1
2
3
4
5
6
7
8
9
10
Reduce: 155
*/
</code></pre>

<h4 id="scan">scan</h4>

<p><img src="/images/programacao-reativa-parte-2-20.png" alt="scan" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#scan-io.reactivex.functions.BiFunction-">scan</a> devolve um <code>Observable</code> que aplica uma função de acumulação sobre os valores emitidos, repassando o novo valor para a função subsequente. Cada retorno da função é emitido pelo novo <code>Observable</code>, diferindo, pois, de uma operação de redução, que gera um único valor final.</p>

<pre><code class="language-java">Observable.range(0, 5)
		.doOnNext(v -&gt; System.out.println(&quot;Value is: &quot; + v)) // valores emitidos do range
		.scan((a, b) -&gt; a + b) // o primeiro parâmetro é o resultado acumulado; o segundo é o valor emitido
		.doOnNext(v -&gt; System.out.println(&quot;Scan result is: &quot; + v)) // resultado da função passada ao scan
		.subscribe();

/*
output:

Value is: 0 // valor emitido pelo range
Scan result is: 0 // nenhum valor acumulado - a função não é aplicada

Value is: 1 // valor emitido pelo range
Scan result is: 1 // 0 + 1 = 1 (esse resultado será passado para a função subsequente)

Value is: 2 // valor emitido pelo range
Scan result is: 3 // 1 + 2 = 3 (e sucessivamente...)

Value is: 3 // valor emitido pelo range
Scan result is: 6 // 3 + 3 = 6

Value is: 4 // valor emitido pelo range
Scan result is: 10 // 6 + 4 = 10
*/
</code></pre>

<h4 id="collect">collect</h4>

<p><img src="/images/programacao-reativa-parte-2-21.png" alt="collect" /></p>

<p>Outra operação comum é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#collect-java.util.concurrent.Callable-io.reactivex.functions.BiConsumer-">collect</a>, que permite coletar os elementos, conforme eles são emitidos, dentro de uma estrutura mutável, como uma <code>Collection</code>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
		.collect(ArrayList::new, (l, v) -&gt; l.add(v)) // o retorno é um Single&lt;ArrayList&gt;
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

[one, two, three, four]
*/
</code></pre>

<h3 id="temporização">Temporização</h3>

<h4 id="window">window</h4>

<p><img src="/images/programacao-reativa-parte-2-22.png" alt="window" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#window-long-">window</a> permite o agrupamento de items em &ldquo;janelas&rdquo;, definidas por quantidade ou tempo. É essencialmente igual ao <code>buffer</code>, com a diferença que os valores são agrupados em um <code>Observable</code> ao invés de um <code>List</code>.</p>

<pre><code class="language-java">Observable.range(0, 10)
		.window(3) // janela com três elementos
		.subscribe(window -&gt; window.toList().subscribe(System.out::println)); // window é um Observable

/*
output:

[0, 1, 2]
[3, 4, 5]
[6, 7, 8]
[9]
*/
</code></pre>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
	.window(2000, TimeUnit.MILLISECONDS) // janela de dois segundos
	.subscribe(window -&gt; window.toList().subscribe(System.out::println));

Thread.sleep(10000);

/*
output: // essa saída pode ter variações

[0, 1]
[2]
[3, 4, 5]
[6, 7]
[8, 9]
*/
</code></pre>

<h4 id="throttle">throttle</h4>

<p>Existem três sabores desse operador: <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleFirst-long-java.util.concurrent.TimeUnit-">throttleFirst</a>, <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleLast-long-java.util.concurrent.TimeUnit-">throttleLast</a>, e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#throttleWithTimeout-long-java.util.concurrent.TimeUnit-">throttleWithTimeout</a>. Os três aplicam uma <strong>supressão</strong> (selecionam um elemento e descartam os demais) sobre os items emitidos dentro de uma janela de tempo, gerando um <code>Observable</code> que reemite o valor adequado, dependendo do caso.</p>

<p>Os operadores <code>throttleFirst</code> e <code>throttleLast</code> geram um <code>Observable</code> que emite <strong>apenas o primeiro ou último item emitidos dentro do intervalo</strong>, descartando os demais.</p>

<p><img src="/images/programacao-reativa-parte-2-23.png" alt="throttleFirst" /></p>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS)
	.throttleFirst(3000, TimeUnit.MILLISECONDS) // reemite apenas o primeiro valor emitido dentro de uma janela de três segundos
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output:

0
4
8
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-24.png" alt="throttleLast" /></p>

<pre><code class="language-java">Observable.interval(1000, TimeUnit.MILLISECONDS) // emite um valor a cada segundo
	.throttleLast(3000, TimeUnit.MILLISECONDS) // reemite apenas o último valor emitido dentro de uma janela de três segundos
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output:

2
4
8
*/
</code></pre>

<p>O operador <code>throttleWithTimeout</code> faz algo diferente: cria um <code>Observable</code> que reemite apenas o item que <strong>não foi seguido por nenhuma outra emissão</strong> dentro do intervalo.</p>

<p><img src="/images/programacao-reativa-parte-2-25.png" alt="throttleWithTimeout" /></p>

<pre><code class="language-java">Observable.interval(3000, TimeUnit.MILLISECONDS) // emite um valor a cada três segundos
		.doOnNext(v -&gt; System.out.println(&quot;Interval: &quot; + v))
		.throttleWithTimeout(2000, TimeUnit.MILLISECONDS) // emite apenas o item que não foi seguido por nenhum outro, dentro do intervalo
		.doOnNext(v -&gt; System.out.println(&quot;Throttled: &quot; + v))
		.subscribe();

Thread.sleep(15000);

/*
output:

Interval: 0		// emitido em 3s
Throttled: 0	// essa emissão não foi seguida por nenhum outra dentro de 2s

// a mesma lógica se aplica aos items abaixo
Interval: 1
Throttled: 1

Interval: 2
Throttled: 2

Interval: 3
Throttled: 3

Interval: 4
*/
</code></pre>

<h4 id="debounce">debounce</h4>

<p><img src="/images/programacao-reativa-parte-2-26.png" alt="debounce" /></p>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#debounce-long-java.util.concurrent.TimeUnit-">debounce</a> têm o mesmo comportamento do <code>throttleWithTimeout</code>; devolve um <code>Observable</code> que inicializa um janela de tempo, e reemite os valores que não foram seguidos por nenhum outro dentro do intervalo (items que não satisfazem essa condição são descartados).</p>

<pre><code class="language-java">Observable.interval(3000, TimeUnit.MILLISECONDS) // emite um valor a cada três segundos
		.doOnNext(v -&gt; System.out.println(&quot;Interval: &quot; + v))
		.debounce(2000, TimeUnit.MILLISECONDS) // emite apenas o item que não foi seguido por nenhum outro, dentro do intervalo
		.doOnNext(v -&gt; System.out.println(&quot;Debounced: &quot; + v))
		.subscribe();

Thread.sleep(15000);

/*
Interval: 0		// emitido em 3s
Debounced: 0	// essa emissão não foi seguida por nenhum outra dentro de 2s

// a mesma lógica se aplica aos items abaixo
Interval: 1
Debounced: 1

Interval: 2
Debounced: 2

Interval: 3
Debounced: 3

Interval: 4
*/
</code></pre>

<p>Uma possibilidade interessante desse operador é definir uma janela de tempo para cada item, usando <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#debounce-io.reactivex.functions.Function-">uma sobrecarga</a> que recebe uma funcão onde é possível calcular o tempo de duração da janela (isso é sinalizado criando um novo <code>Observable</code> para cada item).</p>

<pre><code class="language-java">Observable.interval(1500, TimeUnit.MILLISECONDS)
	.doOnNext(v -&gt; System.out.println(&quot;Interval: &quot; + v))
	.debounce(value -&gt; Observable.timer((value + 1) * 1000, TimeUnit.MILLISECONDS)) // calcula uma janela de tempo para cada item
	.doOnNext(v -&gt; System.out.println(&quot;Debounced: &quot; + v))
	.subscribe();

Thread.sleep(15000);


/*
output:

Observable.interval(1500, TimeUnit.MILLISECONDS)
	.doOnNext(v -&gt; System.out.println(&quot;Interval: &quot; + v))
	.debounce(value -&gt; Observable.timer((value + 1) * 1000, TimeUnit.MILLISECONDS))
	.doOnNext(v -&gt; System.out.println(&quot;Debounced: &quot; + v))
	.subscribe();

Thread.sleep(15000);
*/
</code></pre>

<h3 id="captura-de-elementos">Captura de elementos</h3>

<h4 id="foreach">forEach</h4>

<p><img src="/images/programacao-reativa-parte-2-27.png" alt="forEach" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#forEach-io.reactivex.functions.Consumer-">forEach</a> é essencialmente um <em>alias</em> para o método <code>subscribe</code>.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.forEach(System.out::println);

/*
output:

one
two
three
*/
</code></pre>

<h4 id="filter">filter</h4>

<p><img src="/images/programacao-reativa-parte-2-28.png" alt="filter" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#filter-io.reactivex.functions.Predicate-">filter</a> filtra items emitidos utilizando um <code>Predicate</code>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.filter(v -&gt; v.equals(&quot;one&quot;))
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
*/
</code></pre>

<h4 id="distinct">distinct</h4>

<p><img src="/images/programacao-reativa-parte-2-29.png" alt="distinct" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#distinct--">distinct</a> elimina items duplicados <strong>em qualquer momento da sequência emissão</strong> (a comparação é feita usando o <code>equals</code> do objeto):</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;three&quot;, &quot;one&quot;, &quot;four&quot;)
		.distinct()
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
two
three
four
*/
</code></pre>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#distinctUntilChanged--">distinctUntilChanged</a> é ligeiramente diferente, pois a comparação é feita apenas com o item anterior da sequência. O mesmo código anterior produziria a saída:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;three&quot;, &quot;one&quot;, &quot;four&quot;)
		.distinct()
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
two
one
three
one
four
*/
</code></pre>

<p>O código abaixo demonstra bem a motivação do <code>distinctUntilChanged</code>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;three&quot;)
		.distinctUntilChanged()
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
two
one
three
*/
</code></pre>

<h4 id="first">first</h4>

<p><img src="/images/programacao-reativa-parte-2-30.png" alt="first" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#first-T-">first</a> devolve um <code>Single</code> que emite o primeiro valor da sequência, ou um valor padrão caso o <code>Observable</code> seja completado sem emitir valores.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.first(&quot;zero&quot;) //esse método devolve um Single
		.doOnSuccess(System.out::println) //o Single emite o evento onSuccess
		.subscribe();

/*
output:

one
*/
</code></pre>

<pre><code class="language-java">Observable.empty()
		.first(&quot;zero&quot;)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

zero
*/
</code></pre>

<p>Existem outros sabores desse operadores. O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#firstElement--">firstElement</a> também retorna o primeiro valor da sequência, mas sem um valor padrão caso o mesmo não exista; como, então, o <code>Observable</code> <strong>talvez</strong> emitirá algo, o tipo do retorno é um <code>Maybe</code>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.firstElement() //esse método devolve um Maybe
		.doOnSuccess(System.out::println) //o Maybe emite o evento onSuccess
		.subscribe();

/*
output:

one
*/
</code></pre>

<pre><code class="language-java">Observable.empty()
		.firstElement()
		.doOnSuccess(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;OnCompleted&quot;))
		.subscribe();

/*
output:

OnCompleted
*/
</code></pre>

<p>Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#firstOrError--">firstOrError</a> retorna um <code>Single</code> que pode emitir o primeiro valor da sequência, ou um <code>NoSuchElementException</code> caso o <code>Observable</code> não emita nada:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.firstOrError()
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

one
*/
</code></pre>

<pre><code class="language-java">Observable.empty()
		.firstOrError()
		.doOnError(Throwable::printStackTrace)
		.subscribe();

/*
output:

java.util.NoSuchElementException
	...
*/
</code></pre>

<p>Existem também mais dois operadores semelhantes, chamados <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#single-T-">single</a> e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#singleElement--">singleElement</a>, que convertem um <code>Observable</code> em um <code>Single</code> (caso do método <em>single</em>, que recebe um valor padrão) ou em um <code>Maybe</code> (caso do <em>singleElement</em>). Semânticamente eles são mais elegantes, mas use-os com cuidado porque o objeto resultante irá emitir um erro caso o <code>Observable</code> original emita mais de um valor.</p>

<h4 id="last">last</h4>

<p><img src="/images/programacao-reativa-parte-2-31.png" alt="last" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#last-T-">last</a>, naturalmente, tem um comportamento oposto ao <code>first</code>, devolvendo o último valor emitido.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.last(&quot;zero&quot;)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

one
*/
</code></pre>

<p>Assim como o <code>first</code>, o método <code>last</code> também vem nos sabores <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#lastElement--">lastElement</a> e <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#lastOrError--">lastOrError</a>.</p>

<h4 id="elementat">elementAt</h4>

<p><img src="/images/programacao-reativa-parte-2-32.png" alt="elementAt" /></p>

<p>O operator <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAt-long-">elementAt</a> permite recuperar um valor emitido a partir do seu índice (iniciando em zero); o retorno é encapsulado em um <code>Maybe</code>, portanto, caso o índice em questão não exista, o evento <em>onError</em> não será emitido mas o <code>Maybe</code> será completado sem emitir nada.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.elementAt(1)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

two
*/
</code></pre>

<pre><code class="language-java">Observable.empty()
		.elementAt(1)
		.doOnSuccess(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

/*
output:

OnComplete
*/
</code></pre>

<p>Outros sabores desse método são uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAt-long-T-">sobrecarga</a> que permite passar um valor padrão caso o índice não exista na sequência, e o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#elementAtOrError-long-">elementAtOrError</a>, que devolve um <code>Single</code> que irá publicar o evento <em>onError</em> (com a exceção <code>NoSuchElementException</code>) caso o índice não exista.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.elementAtOrError(1)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

two
*/
</code></pre>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.elementAtOrError(10)
		.doOnSuccess(System.out::println)
		.doOnError(Throwable::printStackTrace)
		.subscribe();

/*
output:

java.util.NoSuchElementException
	...
*/
</code></pre>

<h4 id="take">take</h4>

<p><img src="/images/programacao-reativa-parte-2-33.png" alt="take" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#take-long-">take</a> permite obter os <em>n</em> primeiros elementos emitidos:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
	.take(2)
	.doOnNext(System.out::println)
	.subscribe();

/*
output:

one
two
*/
</code></pre>

<p>Também é possível obter os <em>n</em> últimos com o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeLast-int-">takeLast</a>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
	.takeLast(2)
	.doOnNext(System.out::println)
	.subscribe();

/*
output:

three
four
*/
</code></pre>

<h4 id="skip">skip</h4>

<p><img src="/images/programacao-reativa-parte-2-34.png" alt="skip" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skip-long-">skip</a> descarta os primeiros <em>n</em> elementos emitidos:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
		.skip(2)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

three
four
*/
</code></pre>

<p>Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skipLast-int-">skipLast</a> descarta os <em>n</em> últimos:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
		.skipLast(2)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

one
two
*/
</code></pre>

<h4 id="skipwhile-e-skipuntil">skipWhile e skipUntil</h4>

<p><img src="/images/programacao-reativa-parte-2-35.png" alt="skipWhile" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skipWhile-io.reactivex.functions.Predicate-">skipWhile</a> recebe como parâmetro um <code>Predicate</code>, omitindo os itens emitidos da sequência <strong>enquanto essa condição for verdadeira</strong>, e emite todos os items subsequentes a partir do elemento para o qual a condição for falsa:</p>

<pre><code class="language-java">Observable.range(0, 10)
		.skipWhile(v -&gt; v &lt; 5) //omite todos os elements menores que 5
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

5
6
7
8
9
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-36.png" alt="skipUntil" /></p>

<p>Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#skipUntil-io.reactivex.ObservableSource-">skipUntil</a> recebe um segundo <code>Observable</code>, e devolve um <code>stream</code> que omite todos os itens até que o segundo <code>Observable</code> emita algum valor:</p>

<pre><code class="language-java">
Observable&lt;Long&gt; timer = Observable.timer(5000, TimeUnit.MILLISECONDS); // emite um valor a cada 5 segundos

// o operador skipUntil fará com que o Observable abaixo aguarde o timer emitir algo;
// ou seja, apesar de emitir um valor a cada segundo (mais rapidamente que o timer, portanto), esses valores serão descartados

Observable.interval(1000, TimeUnit.MILLISECONDS)
	.skipUntil(timer)
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output:

5
6
7
8
9
*/
</code></pre>

<h4 id="takewhile-e-takeuntil">takeWhile e takeUntil</h4>

<p><img src="/images/programacao-reativa-parte-2-37.png" alt="takeWhile" /></p>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeWhile-io.reactivex.functions.Predicate-">takeWhile</a> tem uma semântica inversa ao <code>skipWhile</code>; esse operador também recebe um <code>Predicate</code> e retorna um <code>Observable</code> que <strong>captura</strong> os elementos emitidos <strong>enquanto a condição for verdadeira</strong>, descartando os demais a partir do primeiro elemento em que a condição é falsa:</p>

<pre><code class="language-java">Observable.range(0, 10)
		.takeWhile(v -&gt; v &lt; 5) //captura os elementos menores que 5
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

0
1
2
3
4
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-38.png" alt="takeUntil" /></p>

<p>O <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeUntil-io.reactivex.functions.Predicate-">takeUntil</a> recebe um <code>Predicate</code> e devolve um <code>Observable</code> que captura os elementos emitidos <strong>até que a condição seja satisfeita</strong>, e então emite o <em>onCompleted</em>:</p>

<pre><code class="language-java">Observable.range(0, 10)
		.takeUntil(v -&gt; v &gt;= 5) // captura todos menores ou iguais a 5; a partir do momento em que essa condição for satisfeita, os demais serão descartados
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

0
1
2
3
4
5
*/
</code></pre>

<p>Também existe uma <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#takeUntil-io.reactivex.ObservableSource-">sobrecarga</a> desse operador que funciona de maneira análoga ao <code>skipUntil</code> (recebendo um segundo <code>Observable</code>), mas tem um comportamento contrário: captura todos os elementos até que o segundo <code>Observable</code> emita algum valor:</p>

<pre><code class="language-java">Observable&lt;Long&gt; timer = Observable.timer(5000, TimeUnit.MILLISECONDS); // emite um valor a cada 5 segundos

// o operador takeUntil criará um novo Observable que reemitirá os valores até o timer emitir algo, e depois completará
// o Observable abaixo emite valores mais rapidamente que o timer, mas emitirá apenas até o segundo Observable sinalizar

Observable.interval(1000, TimeUnit.MILLISECONDS)
	.takeUntil(timer)
	.doOnNext(System.out::println)
	.doOnComplete(() -&gt; System.out.println(&quot;Completed&quot;))
	.subscribe();

Thread.sleep(10000);

/*
output:

0
1
2
3
Completed
*/
</code></pre>

<h4 id="ignoreelements">ignoreElements</h4>

<p><img src="/images/programacao-reativa-parte-2-39.png" alt="ignoreElements" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#ignoreElements--">ignoreElements</a> ignora todos os itens emitidos, simulando um evento terminal. O retorno desse método um <code>Completable</code>:</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
		.ignoreElements()
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

/*
output:

OnComplete
*/
</code></pre>

<h3 id="condicionais">Condicionais</h3>

<h4 id="all-e-any">all e any</h4>

<p><img src="/images/programacao-reativa-parte-2-40.png" alt="all" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#all-io.reactivex.functions.Predicate-">all</a> devolve um <code>Single</code> do tipo <code>boolean</code>, indicando se <strong>todos</strong> os elementos emitidos atendem uma determinada condição. Já o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#any-io.reactivex.functions.Predicate-">any</a> verifica se <strong>algum</strong> elemento atende à condição:</p>

<pre><code class="language-java">Observable.range(1, 10)
		.all(v -&gt; v &lt;= 5)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

false
*/
</code></pre>

<pre><code class="language-java">Observable.just(2, 4, 6, 8, 10)
		.all(v -&gt; v % 2 == 0)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

true
*/
</code></pre>

<p><img src="/images/programacao-reativa-parte-2-41.png" alt="any" /></p>

<pre><code class="language-java">Observable.range(1, 10)
		.any(v -&gt; v &lt;= 5)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

true
*/
</code></pre>

<pre><code class="language-java">Observable.just(2, 4, 6, 8, 10)
		.all(v -&gt; v % 2 != 0)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

false
*/
</code></pre>

<h4 id="contains">contains</h4>

<p><img src="/images/programacao-reativa-parte-2-42.png" alt="contains" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#contains-java.lang.Object-">contains</a> retorna um <code>Single</code> do tipo <code>boolean</code>, indicando se o <code>Observable</code> emitiu um item específico:</p>

<pre><code class="language-java">Observable.range(0, 5)
		.contains(2)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

true
*/
</code></pre>

<pre><code class="language-java">Observable.range(0, 5)
		.contains(10)
		.doOnSuccess(System.out::println)
		.subscribe();

/*
output:

false
*/
</code></pre>

<h3 id="concatenação-de-streams">Concatenação de streams</h3>

<p>Uma vez que a programação reativa tem no <code>stream</code> sua figura principal, sob o princípio de que &ldquo;tudo é um stream&rdquo; e todas as origens e sequências de dados podem ser representadas em um <code>stream</code>, é muito comum a necessidade de concatenarmos de alguma forma diferentes fluxos de dados. Existem vários operadores para esses casos de uso. Todos os operadores demonstrados abaixo permitem também a concatenação de <code>streams</code> de <strong>tipos diferentes</strong>, o que também é uma necessidade comum (um <code>Observable</code> de <code>Strings</code> ser concatenado a um <code>Observable</code> de números, por exemplo, gerando um novo <code>Observable</code> como resultado).</p>

<h4 id="concat">concat</h4>

<p><img src="/images/programacao-reativa-parte-2-43.png" alt="concat" /></p>

<p><a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concat-java.lang.Iterable-">Existem</a> <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concat-io.reactivex.ObservableSource-io.reactivex.ObservableSource-io.reactivex.ObservableSource-io.reactivex.ObservableSource-">vários</a> <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concatArray-io.reactivex.ObservableSource...-">sabores</a> desse operador. A idéia básica da sua utilização é o formato de um método de fábrica estático que permite concatenar múltiplos <code>Observables</code> para gerar um novo.</p>

<pre><code class="language-java">Observable&lt;String&gt; first = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

Observable&lt;String&gt; second = Observable.just(&quot;four&quot;, &quot;five&quot;, &quot;six&quot;);

Observable&lt;String&gt; third = Observable.just(&quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;);

Observable.concat(first, second, third)
	.doOnNext(System.out::println)
	.subscribe();
</code></pre>

<p>Um ponto-chave dos vários métodos <code>concat</code> é que os <code>Observables</code> que funcionam como fontes de dados são drenados <em>na ordem em que foram enviados</em>, o que significa que o primeiro <code>stream</code> terá todos os seus valores coletados até emitir o <code>onCompleted</code>, e o processo será repetido com o <code>stream</code> seguinte, sucessivamente. Isso parece evidente nesse exemplo, mas nem sempre é o comportamento desejado. Mais abaixo vamos analisar operadores com semânticas diferentes.</p>

<p>Também existe o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#concatMap-io.reactivex.functions.Function-">concatMap</a>, que permite transformar cada elemento em um <code>Observable</code>, e o retorno é um novo <code>Observable</code> que é gerado a partir da concatenação dos <code>streams</code> resultantes:</p>

<pre><code class="language-java">Observable.range(1, 10)
		.concatMap(i -&gt; Observable.just(&quot;hello, i'm the number &quot; + i)) //o retorno será o resultado da concatenação dos Observables gerados por essa função
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

hello, i'm the number 1
hello, i'm the number 2
hello, i'm the number 3
hello, i'm the number 4
hello, i'm the number 5
hello, i'm the number 6
hello, i'm the number 7
hello, i'm the number 8
hello, i'm the number 9
hello, i'm the number 10
*/
</code></pre>

<h4 id="combinelatest">combineLatest</h4>

<p><img src="/images/programacao-reativa-parte-2-44.png" alt="combineLatest" /></p>

<p>Um operador interessante é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#combineLatest-java.lang.Iterable-io.reactivex.functions.Function-">combineLatest</a>, em suas diversas variações. A idéia desse método é gerar um <code>Observable</code> a partir dos <strong>últimos valores emitidos</strong> pelos <code>streams</code> utilizados como fontes de dados, conforme os itens são emitidos.
A função de concatenação recebe um <em>array</em> com todos os valores.</p>

<pre><code class="language-java">Observable&lt;String&gt; first = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

Observable&lt;String&gt; second = Observable.just(&quot;four&quot;, &quot;five&quot;, &quot;six&quot;);

Observable&lt;String&gt; third = Observable.just(&quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;);

// a função de transformação irá receber os últimos valores emitidos como um array.
// nesse exemplo, temos três Observables de entrada. O array será gerado com último valor de cada um e apenas quando os três emitirem algum valor.
// a função de concatenação continuará sendo invocada até que todos terminem (no exemplo abaixo, a &quot;concatenação&quot; é o toString sobre o array).

Observable.combineLatest(Arrays.asList(first, second, third), Arrays::toString)
	.doOnNext(System.out::println)
	.subscribe();

/*
output:

[three, six, seven]
[three, six, eight]
[three, six, nine]
*/
</code></pre>

<p>Uma sobrecarga desse método permite passar vários <code>Observables</code> e uma função que recebe cada valor individual, ao invés de um <em>array</em>:</p>

<pre><code class="language-java">Observable.combineLatest(first, second, third, (a, b, c) -&gt; a + &quot;-&quot; + b + &quot;-&quot; + c)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

three-six-seven
three-six-eight
three-six-nine
*/
</code></pre>

<p>Um método de instância do <code>Observable</code> que tem um comportamento parecido é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#withLatestFrom-java.lang.Iterable-io.reactivex.functions.Function-">withLatestFrom</a>, que gera um novo <code>Observable</code> com os valores emitidos pelo <code>stream</code> combinados com o último valor emitido por um segundo <code>Observable</code> (a lógica de combinação é representada em uma função).</p>

<h4 id="merge">merge</h4>

<p><img src="/images/programacao-reativa-parte-2-45.png" alt="merge" /></p>

<p>Outra maneira de concatenar <code>Observables</code> é o operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#merge-java.lang.Iterable-">merge</a>, que funciona de maneira equivalente ao <code>concat</code>, mas gera um novo <code>Observable</code> com os itens dos <code>streams</code> de origem <strong>conforme eles são emitidos</strong>, independente da ordem em que foram enviados.</p>

<pre><code class="language-java">Observable&lt;String&gt; first = Observable.interval(2000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;First observable: &quot; + v)
		.take(5);

Observable&lt;String&gt; second = Observable.interval(1000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;Second observable: &quot; + v)
		.take(5);

Observable&lt;String&gt; third = Observable.interval(500, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;Third observable: &quot; + v)
		.take(5);

Observable.merge(first, second, third)
	.doOnNext(System.out::println)
	.subscribe();

Thread.sleep(10000);

/*
output:

Third observable: 0
Second observable: 0
Third observable: 1
Third observable: 2
Second observable: 1
First observable: 0
Third observable: 3
Third observable: 4
Second observable: 2
Second observable: 3
First observable: 1
Second observable: 4
First observable: 2
First observable: 3
First observable: 4
*/
</code></pre>

<p>Novamente, a diferença de destaque entre este operador e o <code>concat</code> é que o <code>merge</code> não aguarda um <code>Observable</code> de entrada ser completado para drenar o próximo. Utilize o <code>concat</code> caso precise manter a ordem de emissão dos <code>streams</code> de origem.</p>

<p>Embora o <code>merge</code> também seja um método estático (de fábrica), também é possível realizar essa operação em um <code>Observable</code> já existente, usando o método <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#mergeWith-io.reactivex.ObservableSource-">mergeWith</a>. O comportamento é o mesmo, de modo que o novo <code>Observable</code> reemitirá os valores conforme são emitidos nos <code>streams</code> de origem:</p>

<pre><code class="language-java">Observable.interval(2000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;Source observable: &quot; + v)
		.mergeWith(
				Observable.interval(1000, TimeUnit.MILLISECONDS)
					.map(v -&gt; &quot;Merged observable: &quot; + v)
		)
		.doOnNext(System.out::println)
		.subscribe();

/*
output:

Merged observable: 0
Source observable: 0
Merged observable: 1
Merged observable: 2
Merged observable: 3
Source observable: 1
Merged observable: 4
Merged observable: 5
Source observable: 2
Merged observable: 6
Merged observable: 7
Source observable: 3
Merged observable: 8
Merged observable: 9
Source observable: 4
*/
</code></pre>

<h4 id="zip">zip</h4>

<p><img src="/images/programacao-reativa-parte-2-46.png" alt="zip" /></p>

<p>O operador <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-">zip</a> representa uma operação comum em linguagens funcionais. Esse operador irá concatenar os elementos de <em>n</em> <code>Observables</code> usando uma função de transformação, agrupando os items pelo <strong>índice</strong>. Ou seja, o novo <code>Observable</code> irá emitir primeiro o retorno da função aplicada ao primeiro item de cada <code>stream</code> de entrada; o segundo elemento emitido será o retorno da função aplicada ao segundo item de cada <code>stream</code>, e assim sucessivamente.</p>

<pre><code class="language-java">// nesse exemplo, temos três Observables que emitem valores em intervalos diferentes, e vamos concatena-los usando o zip.
// O Observable gerado irá aguardar os três streams de entrada emitirem valores,
// pois a agregação do zip é realizada usando o índice do elemento emitido.

Observable&lt;Long&gt; first = Observable.interval(2000, TimeUnit.MILLISECONDS);

Observable&lt;Long&gt; second = Observable.interval(500, TimeUnit.MILLISECONDS);

Observable&lt;Long&gt; third = Observable.interval(500, TimeUnit.MILLISECONDS);

Observable.zip(first, second, third, (a, b, c) -&gt; a + &quot; - &quot; + b + &quot; - &quot; + c)
		.doOnNext(System.out::println)
		.subscribe();

Thread.sleep(10000);

/*
output:

0 - 0 - 0
1 - 1 - 1
2 - 2 - 2
3 - 3 - 3
4 - 4 - 4
*/
</code></pre>

<p>O método de instância equivalente é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#zipWith-java.lang.Iterable-io.reactivex.functions.BiFunction-">zipWith</a>, que tem o mesmo comportamento.</p>

<pre><code class="language-java">Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
		.zipWith(Observable.interval(1000, TimeUnit.MILLISECONDS), (a, b) -&gt; a + &quot; - &quot; + b)
		.doOnNext(System.out::println)
		.subscribe();

Thread.sleep(5000);

/*
output:

one - 0
two - 1
three - 2
*/
</code></pre>

<h4 id="amb">amb</h4>

<p><img src="/images/programacao-reativa-parte-2-47.png" alt="amb" /></p>

<p>Outro operador de concatenação é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#amb-java.lang.Iterable-">amb</a>, que gera um <code>Observable</code> que, dados múltiplos <code>streams</code> de entrada, reemite o primeiro elemento do <strong>primeiro Observable que emitir algum valor</strong>, completando a seguir. Os demais <code>Observables</code> são descartados.</p>

<pre><code class="language-java">Observable&lt;String&gt; fast = Observable.timer(1000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;First observable: &quot; + v)
		.take(5);

Observable&lt;String&gt; slow = Observable.timer(2000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;Second observable: &quot; + v)
		.take(5);

Observable.amb(Arrays.asList(fast, slow))
		.doOnNext(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

Thread.sleep(3000);

/*
output:

First observable: 0
OnComplete
*/
</code></pre>

<p>O método de instância equivalente é o <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html#ambWith-io.reactivex.ObservableSource-">ambWith</a>, que tem o mesmo comportamento:</p>

<pre><code class="language-java">Observable.timer(2000, TimeUnit.MILLISECONDS)
		.map(v -&gt; &quot;First observable: &quot; + v)
		.ambWith(
			Observable.timer(1000, TimeUnit.MILLISECONDS) // o segundo Observable emite valores mais rapidamente
					.map(v -&gt; &quot;Second observable: &quot; + v)
		)
		.take(5)
		.doOnNext(System.out::println)
		.doOnComplete(() -&gt; System.out.println(&quot;OnComplete&quot;))
		.subscribe();

/*
output:

Second observable: 0
OnComplete
*/
</code></pre>

<p>Esse operador, embora talvez não pareça a primeira vista, é extremamente útil. Imagine que você precise ler múltiplas fontes de dados, como diversos servidores onde uma informação poderia estar, e quer utilizar a resposta mais rápida; o <code>amb</code> fará exatamente isso para você. Um código que seria complicado se torna trivial com o uso do <code>amb</code>.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Ufa! E pensar que ainda faltaram muitos métodos&hellip;mas para este capítulo da nossa jornada reativa é o suficiente. Nesse post, vimos em detalhes o principal objeto dos frameworks Rx, o <code>Observable</code>, e seus irmãos <code>Completable</code>, <code>Single</code> e <code>Maybe</code>. Também olhamos os objetos do tipo <code>Subject</code>, que são muito úteis em várias situações e bastante utilizados no ecossistema Rx.</p>

<p>Nesse post também vimos em detalhes o verdadeiro poder dessas bibliotecas: os <strong>operadores reativos</strong>, um espetacular conjunto de métodos que tornam tarefas que seriam complicadas quase triviais. E todos esses operadores têm em comum a construção do <code>stream</code> como um <strong>fluxo de dados</strong>, em que as modificações dos dados são <strong>propagadas</strong>, em oposição ao modelo de mudança de estado. Isso facilita sobremaneira o modelo de programação, onde podemos nos basear em funções declarativas e livres de efeitos colaterais. Isso nos dá outros benefícios que iremos explorar no próximo post, onde falaremos sobre <strong>paralelismo</strong>, <strong>programação concorrente</strong> e <strong>contrapressão</strong>.</p>

<p>Apesar do post loooongo, espero que tenha gostado e que seja útil para você na utilização do RxJava! Em caso de dúvidas, críticas ou qualquer outra coisa, sinta-se livre para utilizar a caixa de comentários!</p>


                        <ul class='tag-list'>
                            
                                <li>
                                    <a href='/tags/java/'>java</a>
                                </li>
                            
                                <li>
                                    <a href='/tags/programacao-reativa/'>programacao-reativa</a>
                                </li>
                            
                        </ul>
                        <section class='share'>
                            <a href='#share' class='share-post hide' title='Clique aqui para compartilhar esse post'>Compartilhe</a>
                            <div class='social-share'>
                                <a href='https://www.facebook.com/dialog/share?app_id=644444999041914&href=https%3a%2f%2fblog.elo7.dev%2fprogramacao-reativa-parte-2%2f&display=popup' rel='noopener' target='_blank' class='link-share facebook' title='Clique para compartilhar no Facebook'>
                                    Compartilhar no facebook
                                </a>
                                <a href='https://twitter.com/intent/tweet?text=programa%25C3%25A7%25C3%25A3o-reativa-parte-2-rxjava&url=https%3a%2f%2fblog.elo7.dev%2fprogramacao-reativa-parte-2%2f&hashtags=elo7tech' rel='noopener' target='_blank' class='link-share twitter' title='Clique para compartilhar no Twitter'>
                                    Compartilhar no twitter
                                </a>
                                <a href='https://blog.elo7.dev/programacao-reativa-parte-2/?utm_source=share&utm_medium=copy' class='link-share hide copy' title='Clique para copiar a url'>
                                    Copiar URL
                                </a>
                                <span class='copy-success'>Link copiado</span>
                                <input type='url' value='https://blog.elo7.dev/programacao-reativa-parte-2/?utm_source=share&utm_medium=copy' class='link-input'>
                            </div>
                        </section>
                    </div>
                    <meta itemprop='headline' content='Continuando a série sobre Programação Reativa, agora com um pouco de código!'/>
                    <span itemprop='publisher' itemscope itemtype='http://schema.org/Organization'>
                        <meta itemprop='name' content='Elo7 Tech'/>
                        <meta itemprop='url' content='https://blog.elo7.dev/'/>
                        <span itemprop='logo' itemscope itemtype='http://schema.org/ImageObject'>
                            <link href='https://images.elo7.com.br/assets/v3/desktop/png/logo-elo7.png' itemprop='url'/>
                            <meta itemprop='width' content='100px'/>
                            <meta itemprop='height' content='100px'/>
                        </span>
                    </span>
                    <meta itemprop='mainEntityOfPage' content='Elo7 Serviços de Informática SA'/>

                    <div id='disqus_thread'></div>
                </div>
            </article>
        </main>

        <footer itemscope itemtype='http://schema.org/Organization'>
    <a rel='home' itemprop='url' href='https://blog.elo7.dev/' >
        blog.elo7.dev © <script>now = new Date; document.write(now.getFullYear());</script>
    </a>
    <meta itemprop='name' content='Elo7 Serviços de Informática SA'/>
    <section class='footer-social'>
        <a title='Github do Elo7' rel='external' itemprop='url' href='https://github.com/elo7' target='_blank' class='github'>Github do Elo7</a>
        <a title='Twitter do Elo7' rel='external' itemprop='url' href='https://twitter.com/elo7tech' target='_blank' class='twitter'>Twitter do Elo7</a>
        <a title='RSS do Elo7' rel='external' itemprop='url' href='https://blog.elo7.dev/index.xml' target='_blank' class='rss'>RSS do Elo7</a>
        <a title='Newsletter do Elo7' rel='external' itemprop='url' href='http://eepurl.com/cVUwvH' target='_blank' class='email'>Newsletter do Elo7</a>
    </section>
</footer>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script async src='/js/analytics.js'></script>
<script async src='/js/github.js'></script>
<script async src='/js/vendor/events-amd.js'></script>
<script async src='/js/vendor/ajax.js'></script>
<script async src='/js/vendor/doc.js'></script>
<script type='text/x-mathjax-config'>
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ],
            displayMath: [ ['$$','$$'], ['\[','\]'] ],
            processEscapes: true
        },
    });
</script>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script src='/js/vendor/highlight.js'></script>
<script>hljs.initHighlightingOnLoad();</script>


        <script>
            var disqus_shortname = 'engenhariaelo7';
            var disqus_identifier = '2018-05-21 00:00:00 \x2b0000 UTC:\/programacao-reativa-parte-2\/';
            var disqus_url = 'https:\/\/blog.elo7.dev\/programacao-reativa-parte-2\/';

            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Habilite o JavaScript para ver os comentários</noscript>
        <script async src='/js/post.js'></script>
    </body>
</html>
